支付中台
    
    支付核心
        支付 支付查询 退款 退款查询 异步回调
    目的
        多种支付的情况下，外部调用者需要针对不同类型的支付进行判断并编写参数封装、调用的过程，每次新增一种支付类型也会在调用端增加大量代码。
        支付中台的目的就是对支付参数、支付流程进行通用化，避免出现大量逻辑重复、代码类似的代码，便于维护，同时也要保证可扩展性。
        支付中台一般是针对需要调用三方的支付类型的处理，广义的支付(包括积分支付、券支付等放在支付中台的上层，由上层这个支付业务层处理业务，并决定是否调用底层支付中台)
    架构
        一般支付中台可以是内部使用的，更底层的服务，不对外暴露。可以是http或dubbo协议的。
        也可以是更通用的支付中台，以http协议暴露给多个服务甚至外部服务。    
        
    1.参数的通用化
        支付所需参数都是类似的，可以定义一个通用bean来接收所有支付类型的参数。
        通用bean中的参数名不可能对所有支付都通用，只能表示功能所需参数，具体支付实现中去处理调用三方的传参名字、数据格式的问题。
        甚至可以对所有交易类型的参数都进行通用化。
        返回参数也需要通用化，方便调用者判断调用是否成功，并获取数据。注意返回参数需要脱敏处理。
        
    2.流程的通用化
        支付、退款、查询可以走统一入口，即以一个统一的方法作为入口处理所有支付类型和交易类型的请求，通用请求参数的核心是支付类型和交易类型。
        
        参数解析
            入参一般是json字符串，在调用支付实现方法前还需要相应的参数解析，获取具体的支付实现service，对应该支付实现的实际入参类型，出参类型。
            可以将支付类型->支付实现service这个映射关系放在配置中维护。
        
        认证、签名
            对于内部调用的支付中台，不暴露在外网的，可以不设计签名机制。
            对于通用型的暴露在外网的支付中台，必须要设计认证、签名机制。
        
        防重处理
            接口需要防重
                对于交易类接口，需要避免重复调用，一般在redis缓存中存对应业务的key即可，下次调用发现有key就表示操作正在处理，直接抛出异常。【解决重复支付】
                对于查询类接口，可以对查询结果进行缓存，避免短时间内高频次的重复查询。
            #也可以设计请求序列号，外部传参，支付中台遇到相同的请求序列号则丢弃处理。由于不能保证人为地调用支付中台，这种方式不推荐。
        
        参数校验
            可以进行一些通用的参数校验，通用参数校验完成之后，【回调具体实现的参数校验逻辑】。
        
        调用具体实现方法    
            通过交易类型再调用具体支付实现service的相应方法并获取返回信息。
        
        异常处理
            支付中台抛出的所有异常必须捕获处理，返回对应的信息给外部调用者。
            统一入口捕获具体实现层抛出的异常，可以按需区分异常类型，进行返回处理。
            
        日志记录    
            日志主要分两种类型：
                交易日志，即支付/退款这种需要中间状态的日志；
                调用日志：即基本的入参出参日志，也会记录查询交易操作的日志。
            可以在finally块中进行日志记录，保证日志记录操作一定执行。
            为避免日志写库过程中发生异常而导致主流程失败，可以对这一步操作进行异步处理。
            【交易日志写入数据库之后回调afterPay和afterRefund】
            
    3.异步回调流程的通用化
        部分支付方式存在服务器通知流程，服务器通知(异步回调)又分支付回调和退款回调。
        结合路径参数，可以区分不同的支付类型和交易类型。
        支付中台由于不处理订单业务、收付款业务，异步回调过程也只是进行参数校验、验签、判断交易状态是否成功、金额是否与原支付金额一致(金额校验可以放在业务回调中处理)等。
        
        异步回调成功之后，更新交易日志，然后再回调业务方。    
        交易日志中可以保存业务回调的地址以及业务回调的状态。
        必须保证交易(支付/退款)成功才能调用业务方。可以考虑幂等调用，建议由业务回调处理方法去做幂等处理。
        回调业务需要重试机制(简单的重试机制就是for循环+线程睡眠)。
        
        异步回调日志也需要记录，可以包含在上面的调用日志中，或者独立记录。
    
    4.其他
        对进行中的数据的处理
            异步流程可能由于网络等原因造成流程没有执行完成，比如异步回调可能未成功处理，流程将一直卡在中间状态，因此需要对进行中的数据进行处理。
            单独创建一个定时任务(比如每天凌晨)，对交易日志中当前进行中(无最终结果)的数据进行查询，并更新交易状态。

        退款操作具体支付实现service方法执行前，应该自动获取出原支付信息，具体实现方法可以进行相应处理。
        
        查询类操作，如果查询结果中交易状态是完成的，应该看一下交易日志是否需要对应更新。
    
        交易类操作的超时处理
            支付中台可以不处理三方调用的超时，因为支付中台本身的接口可能也会超时，所以直接都交给调用者处理。
            调用者在调用支付中台时可以将调用逻辑抽取成工具方法，对于交易类操作超时可以手动捕获异常并重新发起一次查询请求。
    
    
支付业务层

       订单可以使用多种支付方式，包括现金、积分、各种优惠类支付等。
       一般对于同一种支付方式只能支付一次，现金支付除外。
       退款应该选择原来的支付方式，原路返回，支持部分退款，但同一种付款方式退款的最大金额不能超过原支付金额。
       如果要全部退款，需要对原先的所有付款方式依次退款，或者使用现金方式全部退掉。
       
       支付业务层是支付中台的上层，支付业务层可以调用不同的下游服务来完成支付逻辑。
       
       支付类型主要有3种：
            1.需要与第三方交互，即交易不是一次性完成的，需要中间状态，如支付宝、微信支付等
            2.直接完成的，如现金支付
            3.不需要与三方交互，但是也需要中间状态，如刷卡支付等
            其他如积分支付可以独立为一种方式
            
       支付业务的主要操作就是对支付明细的操作，支付(或退款)前生成明细，支付(或退款)完成后更新明细，以及支付主表(汇总表)的操作。
            生成明细后，根据支付类型调用支付中台或其他业务系统。
            就算是直接完成的类型，这两步也不能跳步。
            复杂点：【一般是异步操作居多，如果支付结果是失败，需要走反向逻辑，即撤销明细。】
       
       支付中的处理
            一般一种支付方式只能支付一次，如果当前支付类型是否有支付中的数据，需要查一下交易结果，再进行相应的处理。
            #交易类操作(支付、退款)如果调用下游服务后获得的是异常信息，应该主动再查询一次交易结果。
            
       零元支付的处理
            todo
            
       退款业务
            退款业务比较复杂 可能涉及到工单系统     todo
       
       #其他一些健壮性逻辑(按需)
             1.支付时如果订单已经完全支付，则应该走完全支付完成的逻辑，并抛出异常提示不要重复支付。
             2.每次插入支付明细前，先检查已有的支付明细中的进行中的数据，如果是三方支付，按需查询三方交易结果。(这个操作需要分布式锁控制)
                    如果限制一种支付方式只能用一次且当前同类型支付方式正在进行中，则抛出异常；
                    如果支付完成，则更新数据；
                    如果支付失败，则撤销这笔支付明细。
             3.业务回调过程中，发现原支付明细已经撤销，此时应该自动执行退款逻辑。       
       
       
       
       