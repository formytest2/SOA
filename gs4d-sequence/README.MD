**如何生成sequence序列？**

    核心思路：              
        数据库存简单序列值 + 锁控制并发访问
        
        类似于getAndSet或者getAndIncrement的逻辑
               
        多个简单序列值的组合可以以阶乘的方式极大的提高值范围的上限，
        比如一个3位简单序列+一个4位简单序列，结合上日期，每天该业务可以生成1000*10000(千万级别)个不重复的序列值
        
        序列本身应该包含时间部分，并应该单独存储序列时间，生成序列时，序列中的时间参数从配置的时间中获取。
        每天零点左右清除序列值，并更新序列日期为当前日期，
        极端情况下当天所有可用序列值达到上限，可以临时更新配置的序列时间，提前序列时间，保证服务可以继续使用。
        
        例：[2位前缀] + 6位日期(yyMMdd) + 当前序列(补零3位) + 当前序列值(补零4位) + 3位数据标识 
        
    基本功能：   
        不同业务的序列值应该分开；       
        序列值可以连续增长，也可以非连续增长；
        在简单序列的基础上拼接前缀、业务标识、时间标识、数据标识等 形成最终的完整序列；
        可以在程序中使用分布式锁控制对表的并发访问(推荐，扩展性好) 也可以利用数据库的表锁或者自增锁。
        
    高级功能：
        算法接口化，可扩展；
        可以提供复杂版本的算法(比如在单纯的拼接规则上进行打乱)；
        日期时间(年月日格式)中有非常多的空余，可以按一定规则进行随机填充/打乱；
        提供完整序列值的反解功能；
            
    注意：
         序列值所在表不应当有副本表给应用程序读写
         结合锁保证数据的读写一致性，需要分布式锁本身具有高可用性    
         
         一般来说可以没有业务标识，不同业务的完整序列值可以重复；
         对于存在分库分片的系统，应该有数据标识，保证需要关联查询的数据能够路由到同一个分片上。
         
         一般来说 序列的位数不宜过大 最好不超过19 有其是作为业务主键时(因为主键最好采用数值型，如mysql中使用bigint类型 长度有限制)
        
    优化：
        由于所有服务使用sequence服务操作单表，数据库压力非常大，应该有缓存机制
        
        业务拆分
            对于不同的业务，其序列是完全独立的，可以拆分到不同的表中，减轻读写压力。
            其实还是存在单表中，每个业务一个数据行来表示就可以了，没有表级别的操作，业务之间是隔离的。
    
        缓存机制
            序列配置可以缓存(redis、jvm内存)(配置一般不变，如果变化，提供一个删除缓存的入口即可，下次会自动重新加载新数据到缓存)
            序列本身可以进行缓存(redis)或者存在本地文件
            序列值操作可以使用jvm内存
            
        缓存落库
            触发时机
                1.设定一个缓存触发值cache_num，当缓存的序列值是cache_num的整数倍时，进行一次落盘
                2.当前序列值是最大序列值的1/3时进行一次写库
            
        缓存丢失问题        
            结合缓存触发机制，当缓存中不存在数据时且非第一次初始数据，从数据库中读取的序列值应该加上cache_num之后更新到数据库和缓存。
            这虽然可能导致一定的不连续 但是能保证序列不会重复。
            
   其他：  
        1.雪花算法，参考[https://github.com/bluecatlee/algorithm/tree/master/snowflake](https://github.com/bluecatlee/algorithm/tree/master/snowflake)
        2.不使用数据库存储序列值，使用文件存储或者zookeeper存储，结合zk的监听机制去更新文件内容       